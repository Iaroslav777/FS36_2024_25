//1. Реалізувати алгоритм: сортування бульбашкою для наступного масиву
//   [1, 2, 5, 4, 10, 3, 13, 11, 100, 8, 15, 20, 19]

let arr = [1, 2, 5, 4, 10, 3, 13, 11, 100, 8, 15, 20, 19];
console.log("1.)\n" + arr);
let countI = 0;
let countIAndJ = 0;
for (let i = 0; i < arr.length - 1; i++) {
  for (let j = 0; j < arr.length - 1 - countI; j++) {
    if (arr[j] > arr[j + 1]) {
      //[arr[j],arr[j+1]] = [arr[j+1],arr[j]];//як варіант, деструктуризацією зробити
      let t = arr[j];
      arr[j] = arr[j + 1];
      arr[j + 1] = t;
    }
    countIAndJ++;
  }
  countI++;
}
console.log(arr + " => " + countIAndJ + " ітерацій");

// 2. Вивести всі алгоритми цієї лекції і попередньої в функції, викличте функції
console.log("\n2.) линийний алгоритм\n");

function linFunk(num) {
  // линийний
  let arr = [1, 2, 5, 4, 10, 3, 13, 11, 100, 8, 15, 20, 19];
  for (let i = 0; i < arr.length; i++) {
    if (num === arr[i]) {
      console.log("Ура, знайшов цифру " + num + " в " + i + "-му індексу!");
      return; //закінчив примусово функцію, пом'ятаю так в с++ робив, тут теж спрацювало)
      //інакше коли писав тут break;, то воно тільки на один рівень підіймалось і
      // завжди, ще виводило consol.log нижче, що немає тут цієї цифри
    }
  }
  console.log(
    "В даному масиві: " + arr + "\nНажаль, такої " + num + " цифри немає."
  );
}
linFunk(19);
linFunk(100);
linFunk(101);

//2. бінарний
console.log("\n2.) бінарний алгоритм\n");

function binFunk() {
  console.log("Привіт, я функція бінарного пошуку");
  let arr = [1, 2, 3, 4, 5, 8, 10, 11, 13, 15, 19, 20, 100];
  let foundNum = 5; // наприклад, чи є 5?
  let i = 0; // скількі ітерацій пошуку
  let start = 0;
  let finish = arr.length - 1;
  while (start <= finish) {
    i++;
    let key = Math.floor((start + finish) / 2);

    if (foundNum === arr[key]) {
      console.log(
        "Ура, знайшов " +
          foundNum +
          " в " +
          key +
          "-му індексі за " +
          i +
          " ітерацій"
      );
      return; //завершаємо роботу функціі
    } else if (foundNum > arr[key]) {
      start = key + 1;
    } else if (foundNum < arr[key]) finish = key - 1;
  }
  console.log("Нажаль, такоі цифри немає.");
}

// викликаю функцію бинарного пошуку
binFunk();

//2. бульбашкою
console.log("\n2.) бульбашковий алгоритм сортування\n");
function bubbleFunk() {
  let arr = [1, 2, 5, 4, 10, 3, 13, 11, 100, 8, 15, 20, 19];
  for (let i = 0; i < arr.length; i++) {
    for (let j = 0; j < arr.length - i - 1; j++) {
      if (arr[j] > arr[j + 1]) {
        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
      } //поменяли місцями значення
    }
  }
  console.log(arr + " \nвідсортовано бульбашковим алгоритмом");
}

//виклик бульбашкової функціі
bubbleFunk();

//3 Створіть функцію яка виводить в консоль пояснення того що таке hoisting
console.log("\n3.) функція - пояснення hoisting\n");
function whatIsHoistingFunk() {
  console.log(
    `Hoisting - це коли спершу перед компіляцією(шнтерпритацією) кода
    всі оголошені функціі з словом function та всі змінні var
    підіймаються вверх коду, при цьому, функціі підіймаються цілком,
    а змінні var - тількі назва змінноє без іі значення.`
  );
}

// викликаю функцію про hoisting
whatIsHoistingFunk();

//  4. Створіть функцію яка виводить в консоль пояснення що таке scope
console.log("\n4.) функція - пояснення scope\n");
function whatIsScopeFunk() {
  console.log(
    `Scope || Lexical Environment - це область видимості, 
    буває: блочний, внутрі функціі та глобальний scope простіше кажучі, це {} - 
    все, що знаходиться між фігурними скобками. поміщені туди дані не відни за межамі {},
    но зовні створені let змінні, наприклад, відна во вкладених {{тут відна}}.`
  );
}

// викликаю функцію про scope
whatIsScopeFunk();

// 5. Створіть функцію яка виводить в консоль пояснення чим поганий var
console.log("\n5.) функція - пояснення чим поганий var\n");
function whatIsVarFunk() {
  console.log(
    `Var - це засторілий тип змінної, саме погане, 
    що var може бути використана поза блочной областю видимості,як let та const, 
    її краще не використовувати, 
    тому що вона піднімається разом hoisting з function-функціями вверх і 
    можуть var від цього вести себе непредсказуємо. var може бути використана 
    до її оголошенняя. далі, вона себе веде непредсказуємо і її 
    сложно відслідкувати, як вона себе поведе в коді.`
  );
}

// викликаю функцію про scope
whatIsVarFunk();
